package main

import "fmt"

// Задача: как отработает код? Будет ли паника?
// https://youtu.be/yM7Z6H1G-rE?si=h1wuiqOOLXho_JbJ
type I interface {
	Foo()
}

type S struct {
}

func (s *S) Foo() {
	fmt.Println("foo")
}

// Пояснение: Несмотря на то, что res равно nil, она возвращается как значение типа интерфейса I.
func Build() I {
	var res *S
	return res
}

func main() {
	i := Build()
	if i != nil { // тут ничего не сломается, несмотря на то что i не инициализирован
		i.Foo()
	} else {
		fmt.Println("nil")
	}
}

// Пояснение:

// 1. Объявление интерфейса и структуры:
//
//    * Определяется интерфейс I с одним методом Foo().
//    * Объявляется структура S, которая реализует интерфейс I, определяя метод Foo().

// 2. Функция Build:
//
//    * В этой функции создается переменная res типа *S (указатель на структуру S), которая инициализируется значением nil.
//    * Несмотря на то, что res равно nil, она возвращается как значение типа интерфейса I.

// 3. Что происходит при возврате значения из функции Build?:
//
//    При возврате res происходит следующее:
//        * В Go интерфейс представляет собой структуру, которая содержит два поля: type и value.
//        * Поле type содержит информацию о том, к какому типу принадлежит значение, а поле value хранит само значение.
//        * В данном случае res типа *S, поэтому type будет указателем на S, а value будет nil.

// 4. Проверка на nil:
//
//    В main, переменная i получает значение из функции Build().
//    Проверка if i != nil работает так:
//        В Go интерфейс считается nil, если оба поля type и value в его внутреннем представлении равны nil.
//
//	 Когда вызывается i.Foo(), Go вызывает метод Foo структуры S через нулевой указатель. Это допустимо в Go, так как методы могут быть вызваны на нулевых указателях, если они не пытаются разыменовать этот указатель внутри метода.
//	 Метод Foo() не делает этого, поэтому программа работает корректно и выводит foo.

// Вывод
//
// Этот код работает из-за того, что в Go интерфейсное значение может
// содержать конкретный тип и nil значение, и из-за того, что вызов методов
// через нулевой указатель разрешен, если метод не разыменовывает указатель.
